#' @title Parameter estimation for the reparameterized Chen distribution
#' @description
#' The Maximum likelihood estimate for the pair of parameters is numerically
#' approximated with optim from the stats package. The estim_chen_rpr function is
#' effectivelly a wrapper for optim, but it defines and uses the Chen
#' log-likelihood function as well.
#'
#'
#' @param y A numeric vector, or coercible to vector using `as.vector(unlist())`.
#' Values sampled from a reparameterized Chen distribution.
#' @param method The optimisation method used by optim, default is BFGS
#' @param tau The quantile for the reparameterized distribution
#' @param full If the return should be the entire list by optim or just the parameter
#' estimations
#' @param clvl The confidence level for calculating the confidence intervals. If NULL no confidence
#' intervals will be calculated. Default in NULL.
#' @return If clvl is set to NULL (default) and full is set to TRUE(default)
#'  than the return is lenght 2 numeric vector with the parameter estimations. If
#'  clvl is a number, than the return is a 3x2 matrix with the parameter estimations
#'  and their confidence intervals. If full is set to TRUE than the return is a
#'  list, having by default 6 elements, if clvl is a number than the list will
#'  have 7 elements with the last one being the matrice of confidence intervals.
#' @importFrom stats median optim qnorm
#' @importFrom boot boot boot.ci
#' @export
#'
#' @examples
#' estim_chen_rpr(rchen(100, c(0.7,7)), tau = 0.5)
#'
estim_chen_rpr <- function(y, tau = 0.5, clvl = NULL, n_bootstrap = NULL){
  y <- as.vector(unlist(y))
  checkmate::assert_numeric(y, lower = 0, any.missing = F)
  checkmate::assert_number(tau, lower = 0, upper = 1)
  checkmate::assert_number(clvl, null.ok = T, lower = 0, upper = 1)
  checkmate::assert_number(n_bootstrap, null.ok = T, lower = 1)

  if (!is.null(n_bootstrap)) {
    error_count <- 0
    boot_func <- function(data, indices) { # Function that receives the indices as generated by boot::boot to take a sample from the data
      bootstrap_y <- data[indices]

      tryCatch({suppressWarnings(bootstrap_estim <- stats::optim(par = c(0.7, 4),
                                                                 fn = log_likelihood_rpr,
                                                                 y = bootstrap_y,
                                                                 tau = tau,
                                                                 method = "BFGS",
                                                                 hessian = F,
                                                                 control = list(fnscale = -1)))
        return(bootstrap_estim$par)
      }, error = function(e) {
        error_count <<- error_count + 1
        return(c(-1, -1))
      })
    }

    boot_results <- boot::boot(data = y, statistic = boot_func, R = n_bootstrap) # Where the bootstrap actually occurs
    boot_results$t <- boot_results$t[!(boot_results$t[, 1] == -1), ]
    boot_results$R <- boot_results$R - error_count

    if (!is.null(clvl)) {
      boot_ci_lambda <- boot::boot.ci(boot_results, type = "basic", index = 1, conf = clvl) # Specifying index because there are 2 parameters
      boot_ci_delta <- boot::boot.ci(boot_results, type = "basic", index = 2, conf = clvl)
      lambda_ci <- boot_ci_lambda$basic[c(4,5)]
      delta_ci <- boot_ci_delta$basic[c(4,5)]
      ci <- cbind(lambda_ci, delta_ci)
      rownames(ci) <- c("lower bound", "upper bound")
      out <- list(t0 = boot_results$t0,
                  t = colMeans(boot_results$t),
                  ci = ci,
                  non_convergent_iterations = error_count)

    } else {
      out <- list(t0 = boot_results$t0,
                  t = colMeans(boot_results$t),
                  non_convergent_iterations = error_count)
    }
    return(out)

  } else{
    suppressWarnings(estim <- stats::optim(par = c(0.7, 5),
                                           fn = log_likelihood_rpr,
                                           y = y,
                                           tau = tau,
                                           method = "BFGS",
                                           hessian = TRUE,
                                           control = list(fnscale = -1)))
    param <- estim$par
    if (!is.null(clvl)) {
      inf <- solve(-estim$hessian)
      a <- stats::qnorm(1 - (1 - clvl)/2) * sqrt(diag(inf))
      lower_bound <- param - a
      upper_bound <- param + a
      ci <- rbind(lower_bound, upper_bound)
      colnames(ci) <- c("lambda_ci", "mu_ci")
      out <- list(t = param,
                  ci = ci)
    } else {
      out <- list(t = param)
    }
    return(out)
  }
}

log_likelihood_rpr <- function(y, theta, tau){
  lambda <- theta[1]
  mu <- theta[2]
  n <- length(y)
  ll <- suppressWarnings(sum((log(log(1 - tau) / (1 - exp(mu^lambda))) +
                           log(lambda) + (lambda - 1) * log(y) +
                           (log(1 - tau) / (1 - exp(mu^lambda))) * (1 - exp(y^lambda)) + (y^lambda))))
  return(ll)
}
